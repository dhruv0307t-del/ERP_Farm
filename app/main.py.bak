from datetime import date, datetime, timedelta
from enum import Enum
from typing import Optional, List

from fastapi import FastAPI, Request, Form, Depends, HTTPException
from fastapi.responses import HTMLResponse, RedirectResponse
from fastapi.templating import Jinja2Templates
from sqlmodel import SQLModel, Field, Session, select, create_engine

# --- App & templates ---
app = FastAPI(title="Cattle ERP - Stage 2 (Breeding & Calving)")
templates = Jinja2Templates(directory="templates")
engine = create_engine("sqlite:///erp.db", echo=False)

# --- Constants ---
DEFAULT_GESTATION_DAYS = 283  # cows (adjust per breed later)


# --------------------
# Models
# --------------------
class Breed(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    name: str


class Animal(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    tag_no: str = Field(index=True, unique=True)
    sex: str  # "F" or "M"
    birthdate: date
    breed_id: Optional[int] = Field(default=None, foreign_key="breed.id")
    created_at: datetime = Field(default_factory=datetime.utcnow)


class MilkYieldDaily(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    animal_id: int = Field(foreign_key="animal.id", index=True)
    entry_date: date = Field(index=True)
    am_liters: float = 0.0
    pm_liters: float = 0.0
    total_liters: float = 0.0


class BreedingType(str, Enum):
    Heat = "Heat"
    AI = "AI"
    NaturalService = "NaturalService"
    PDPositive = "PDPositive"
    PDNegative = "PDNegative"


class BreedingEvent(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    animal_id: int = Field(foreign_key="animal.id", index=True)
    entry_date: date = Field(index=True)  # event date
    event_type: BreedingType
    bull_id: Optional[str] = None
    semen_batch: Optional[str] = None
    notes: Optional[str] = None
    created_at: datetime = Field(default_factory=datetime.utcnow)


class Gestation(SQLModel, table=True):
    id: Optional[int] = Field(default=None, primary_key=True)
    animal_id: int = Field(foreign_key="animal.id", index=True, unique=True)
    service_date: Optional[date] = None
    predicted_calving_date: Optional[date] = Field(default=None, index=True)
    actual_calving_date: Optional[date] = None
    gestation_days_pred: Optional[int] = None
    gestation_days_actual: Optional[int] = None


# --------------------
# DB session helper
# --------------------
def get_session():
    with Session(engine) as session:
        yield session


# --------------------
# Startup: create tables & seed
# --------------------
@app.on_event("startup")
def init_db():
    SQLModel.metadata.create_all(engine)
    with Session(engine) as session:
        if not session.exec(select(Breed)).first():
            session.add_all([Breed(name="HF"), Breed(name="Jersey")])
            session.commit()


# --------------------
# Helpers for totals and chart data
# --------------------
def compute_today_total(session: Session) -> float:
    rows = session.exec(
        select(MilkYieldDaily).where(MilkYieldDaily.entry_date == date.today())
    ).all()
    return sum(r.total_liters for r in rows)


def last_n_days_chart(session: Session, n: int = 14):
    labels = []
    values = []
    for i in range(n - 1, -1, -1):
        d = date.today() - timedelta(days=i)
        labels.append(d.strftime("%b %d"))
        day_total = sum(
            r.total_liters
            for r in session.exec(
                select(MilkYieldDaily).where(MilkYieldDaily.entry_date == d)
            ).all()
        )
        values.append(round(day_total, 2))
    return labels, values


# --------------------
# Routes (root/home/dashboard)
# --------------------
@app.get("/", response_class=HTMLResponse)
def home(request: Request, session: Session = Depends(get_session)):
    """
    Real homepage — renders templates/home.html (NOT a redirect).
    """
    animals = session.exec(select(Animal)).all()
    today_total = compute_today_total(session)
    return templates.TemplateResponse(
        "home.html",
        {"request": request, "total_animals": len(animals), "today_milk": today_total},
    )


@app.get("/home", response_class=HTMLResponse)
def home_alias(request: Request, session: Session = Depends(get_session)):
    """
    Alias so links to /home will also work.
    """
    return home(request=request, session=session)


@app.get("/dashboard", response_class=HTMLResponse)
def dashboard(request: Request, session: Session = Depends(get_session)):
    total_animals = len(session.exec(select(Animal)).all())
    today_milk = compute_today_total(session)
    labels_7, values_7 = last_n_days_chart(session, 7)
    avg_7 = round((sum(values_7) / 7) if values_7 else 0.0, 2)
    pregnant = len(
        session.exec(select(Gestation).where(Gestation.predicted_calving_date != None)).all()
    )
    chart_labels, chart_values = last_n_days_chart(session, 14)
    return templates.TemplateResponse(
        "dashboard.html",
        {
            "request": request,
            "total_animals": total_animals,
            "today_milk": today_milk,
            "avg_7": avg_7,
            "pregnant": pregnant,
            "chart_labels": chart_labels,
            "chart_values": chart_values,
        },
    )


# --------------------
# Animals & other endpoints (same as before)
# --------------------
@app.get("/animals", response_class=HTMLResponse)
def list_animals(request: Request, session: Session = Depends(get_session)):
    animals = session.exec(select(Animal)).all()
    breeds = session.exec(select(Breed)).all()
    return templates.TemplateResponse(
        "animals.html",
        {"request": request, "animals": animals, "breeds": breeds},
    )


@app.post("/animals")
def create_animal(
    tag_no: str = Form(...),
    sex: str = Form(...),
    birthdate: date = Form(...),
    breed_id: int = Form(...),
    session: Session = Depends(get_session),
):
    if sex not in ("F", "M"):
        raise HTTPException(status_code=400, detail="sex must be 'F' or 'M'")
    exists = session.exec(select(Animal).where(Animal.tag_no == tag_no)).first()
    if exists:
        raise HTTPException(status_code=400, detail="tag_no already exists")
    animal = Animal(tag_no=tag_no, sex=sex, birthdate=birthdate, breed_id=breed_id)
    session.add(animal)
    session.commit()
    return RedirectResponse(url="/animals", status_code=303)


@app.get("/animals/{animal_id}", response_class=HTMLResponse)
def animal_detail(animal_id: int, request: Request, session: Session = Depends(get_session)):
    animal = session.get(Animal, animal_id)
    if not animal:
        raise HTTPException(status_code=404, detail="Not found")
    yields = session.exec(
        select(MilkYieldDaily).where(MilkYieldDaily.animal_id == animal_id).order_by(MilkYieldDaily.entry_date.desc())
    ).all()
    events: List[BreedingEvent] = session.exec(
        select(BreedingEvent).where(BreedingEvent.animal_id == animal_id).order_by(BreedingEvent.entry_date.desc(), BreedingEvent.id.desc())
    ).all()
    gest = session.exec(select(Gestation).where(Gestation.animal_id == animal_id)).first()
    days_left = None
    overdue_days = None
    if gest and gest.predicted_calving_date:
        delta = (gest.predicted_calving_date - date.today()).days
        if delta >= 0:
            days_left = delta
        else:
            overdue_days = -delta
    return templates.TemplateResponse(
        "animal_detail.html",
        {"request": request, "animal": animal, "yields": yields, "events": events, "gest": gest, "days_left": days_left, "overdue_days": overdue_days, "BreedingType": BreedingType},
    )


@app.post("/milk/{animal_id}")
def add_milk(animal_id: int, date_: date = Form(...), am: float = Form(0.0), pm: float = Form(0.0), session: Session = Depends(get_session)):
    total = am + pm
    if total < 0 or total > 70:
        raise HTTPException(status_code=400, detail="Invalid milk value (0–70 L)")
    entry = MilkYieldDaily(animal_id=animal_id, entry_date=date_, am_liters=am, pm_liters=pm, total_liters=total)
    session.add(entry)
    session.commit()
    return RedirectResponse(url=f"/animals/{animal_id}", status_code=303)


@app.post("/breeding/{animal_id}/event")
def add_breeding_event(animal_id: int, event_date: date = Form(...), event_type: BreedingType = Form(...), bull_id: Optional[str] = Form(None), semen_batch: Optional[str] = Form(None), notes: Optional[str] = Form(None), session: Session = Depends(get_session)):
    animal = session.get(Animal, animal_id)
    if not animal:
        raise HTTPException(status_code=404, detail="Animal not found")
    if animal.sex != "F":
        raise HTTPException(status_code=400, detail="Breeding only for females")
    if event_date > date.today() + timedelta(days=1):
        raise HTTPException(status_code=400, detail="Future event date not allowed")
    ev = BreedingEvent(animal_id=animal_id, entry_date=event_date, event_type=event_type, bull_id=bull_id, semen_batch=semen_batch, notes=notes)
    session.add(ev)
    gest = session.exec(select(Gestation).where(Gestation.animal_id == animal_id)).first()
    if event_type in (BreedingType.AI, BreedingType.NaturalService):
        if not gest:
            gest = Gestation(animal_id=animal_id)
            session.add(gest)
        gest.service_date = event_date
        gest.predicted_calving_date = event_date + timedelta(days=DEFAULT_GESTATION_DAYS)
        gest.gestation_days_pred = DEFAULT_GESTATION_DAYS
    elif event_type == BreedingType.PDPositive:
        if gest and not gest.predicted_calving_date and gest.service_date:
            gest.predicted_calving_date = gest.service_date + timedelta(days=DEFAULT_GESTATION_DAYS)
            gest.gestation_days_pred = DEFAULT_GESTATION_DAYS
    elif event_type == BreedingType.PDNegative:
        if gest:
            gest.service_date = None
            gest.predicted_calving_date = None
            gest.gestation_days_pred = None
    session.commit()
    return RedirectResponse(url=f"/animals/{animal_id}", status_code=303)


@app.post("/gestation/{animal_id}/calved")
def mark_calved(animal_id: int, calving_date: date = Form(...), session: Session = Depends(get_session)):
    gest = session.exec(select(Gestation).where(Gestation.animal_id == animal_id)).first()
    if not gest:
        raise HTTPException(status_code=400, detail="No active gestation to close")
    gest.actual_calving_date = calving_date
    if gest.service_date:
        gest.gestation_days_actual = (calving_date - gest.service_date).days
    session.commit()
    return RedirectResponse(url=f"/animals/{animal_id}", status_code=303)
